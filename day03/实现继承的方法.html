<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 原型继承
        //优点：通过原型继承多个引用类型的属性和方法
        //缺点：
        // function Super(){
        //     this.a = 6;
        // }
        // Super.prototype.say = function() {
        //     console.log('你好');
        // }
        // function Sub() {};
        // Sub.prototype = new Super();
        // const test = new Sub();
        // console.log( test.say() );


        //构造函数
        // function Super() {
        //     this.a = [1, 2];
        // }
        // function Sub() {};
        // Sub.prototype = new Super();
        // const test = new Sub();
        // test.a.push(3)
        // console.log(test.a);
        // const test1 = new Sub();
        // console.log(test1.a);


        // 盗用构造函数
        // let Super = function() {
        //     this.a = 6;
        // }
        // let Sub = function() {
        //     console.log( this, 'this' ); // Sub {} 'this'
        //     Super.call(this);
        //     this.b = 2;
        // }
        // Sub.prototype.c = 3;
        // const test = new Sub();
        // console.log( test, 'test' );  // Sub {a: 6, b: 2} 'test'


        //组合继承--原型的继承+盗用构造函数继承
        // function Super() {
        //     this.a = [1, 2];
        // }
        // Super.prototype.say = function() {
        //     console.log( 'hhh' );
        // };
        // function Sub() {
        //     Super.call(this);
        //     this.b = 2;
        // }
        // Sub.prototype = new Super();
        // const test1 = new Sub();
        // console.log( test1.say() );
        // test1.a.push(7);
        // console.log( test1.a );
        // const test2 = new Sub();
        // console.log( test2.a );


        //原型式继承
        // es5之前写法
        // const obj = {a: 1};
        // function createObj(b) {
        //     function Fn(){};
        //     Fn.prototype = b;
        //     return new Fn();
        // }
        // const test = createObj(obj);
        // console.log(test);

        // es5之后写法
        // const obj = { a: 1}
        // const test = Object.create(obj)
        // console.log(test);

        // 寄生式继承
        // function createObj(a){
        //     let clone = ObjectCopy(a);
        //     clone.say = function() {
        //         console.log('hhhh');
        //     }
        //     return clone;
        // }
        // const obj = { a: 1};
        // const test = createObj(obj)

        
        //寄生式组合继承
        //优点：继承了所有的东西，修改的时候也不会被污染
        // function Super () {
        //     this.a = [1, 2];
        // }
        // Super.prototype.say = function() {
        //     console.log('hhh');
        // }
        // function Sub(){
        //     Super.call(this);
        //     this.b = 2;
        // }
        // Sub.prototype = Object.create(Super.prototype);
        // Sub.prototype.constructor = Sub;
        // const test = new Sub();
        // console.log(test);

    </script>
    
    <script>
        // 原型继承
        //优点：通过原型继承多个引用类型的属性和方法
        //缺点：
        // function Super(){
        //     this.a = 6;
        // }
        // Super.prototype.say = function() {
        //     console.log('你好');
        // }
        // function Sub() {};
        // Sub.prototype = new Super();
        // const test = new Sub();
        // console.log( test.say() );


        //构造函数
        // function Super() {
        //     this.a = [1, 2];
        // }
        // function Sub() {};
        // Sub.prototype = new Super();
        // const test = new Sub();
        // test.a.push(3)
        // console.log(test.a);
        // const test1 = new Sub();
        // console.log(test1.a);


        // 盗用构造函数
        // let Super = function() {
        //     this.a = 6;
        // }
        // let Sub = function() {
        //     console.log( this, 'this' ); // Sub {} 'this'
        //     Super.call(this);
        //     this.b = 2;
        // }
        // Sub.prototype.c = 3;
        // const test = new Sub();
        // console.log( test, 'test' );  // Sub {a: 6, b: 2} 'test'


        //组合继承--原型的继承+盗用构造函数继承
        // function Super() {
        //     this.a = [1, 2];
        // }
        // Super.prototype.say = function() {
        //     console.log( 'hhh' );
        // };
        // function Sub() {
        //     Super.call(this);
        //     this.b = 2;
        // }
        // Sub.prototype = new Super();
        // const test1 = new Sub();
        // console.log( test1.say() );
        // test1.a.push(7);
        // console.log( test1.a );
        // const test2 = new Sub();
        // console.log( test2.a );


        //原型式继承
        // es5之前写法
        // const obj = {a: 1};
        // function createObj(b) {
        //     function Fn(){};
        //     Fn.prototype = b;
        //     return new Fn();
        // }
        // const test = createObj(obj);
        // console.log(test);

        // es5之后写法
        // const obj = { a: 1}
        // const test = Object.create(obj)
        // console.log(test);

        // 寄生式继承
        // function createObj(a){
        //     let clone = ObjectCopy(a);
        //     clone.say = function() {
        //         console.log('hhhh');
        //     }
        //     return clone;
        // }
        // const obj = { a: 1};
        // const test = createObj(obj)

        
        //寄生式组合继承
        //优点：继承了所有的东西，修改的时候也不会被污染
        // function Super () {
        //     this.a = [1, 2];
        // }
        // Super.prototype.say = function() {
        //     console.log('hhh');
        // }
        // function Sub(){
        //     Super.call(this);
        //     this.b = 2;
        // }
        // Sub.prototype = Object.create(Super.prototype);
        // Sub.prototype.constructor = Sub;
        // const test = new Sub();
        // console.log(test);

    </script>


    <script>
        // 原型继承
        //优点：通过原型继承多个引用类型的属性和方法
        //缺点：
        // function Super(){
        //     this.a = 6;
        // }
        // Super.prototype.say = function() {
        //     console.log('你好');
        // }
        // function Sub() {};
        // Sub.prototype = new Super();
        // const test = new Sub();
        // console.log( test.say() );


        //构造函数
        // function Super() {
        //     this.a = [1, 2];
        // }
        // function Sub() {};
        // Sub.prototype = new Super();
        // const test = new Sub();
        // test.a.push(3)
        // console.log(test.a);
        // const test1 = new Sub();
        // console.log(test1.a);


        // 盗用构造函数
        // let Super = function() {
        //     this.a = 6;
        // }
        // let Sub = function() {
        //     console.log( this, 'this' ); // Sub {} 'this'
        //     Super.call(this);
        //     this.b = 2;
        // }
        // Sub.prototype.c = 3;
        // const test = new Sub();
        // console.log( test, 'test' );  // Sub {a: 6, b: 2} 'test'


        //组合继承--原型的继承+盗用构造函数继承
        // function Super() {
        //     this.a = [1, 2];
        // }
        // Super.prototype.say = function() {
        //     console.log( 'hhh' );
        // };
        // function Sub() {
        //     Super.call(this);
        //     this.b = 2;
        // }
        // Sub.prototype = new Super();
        // const test1 = new Sub();
        // console.log( test1.say() );
        // test1.a.push(7);
        // console.log( test1.a );
        // const test2 = new Sub();
        // console.log( test2.a );


        //原型式继承
        // es5之前写法
        // const obj = {a: 1};
        // function createObj(b) {
        //     function Fn(){};
        //     Fn.prototype = b;
        //     return new Fn();
        // }
        // const test = createObj(obj);
        // console.log(test);

        // es5之后写法
        // const obj = { a: 1}
        // const test = Object.create(obj)
        // console.log(test);

        // 寄生式继承
        // function createObj(a){
        //     let clone = ObjectCopy(a);
        //     clone.say = function() {
        //         console.log('hhhh');
        //     }
        //     return clone;
        // }
        // const obj = { a: 1};
        // const test = createObj(obj)

        
        //寄生式组合继承
        //优点：继承了所有的东西，修改的时候也不会被污染
        // function Super () {
        //     this.a = [1, 2];
        // }
        // Super.prototype.say = function() {
        //     console.log('hhh');
        // }
        // function Sub(){
        //     Super.call(this);
        //     this.b = 2;
        // }
        // Sub.prototype = Object.create(Super.prototype);
        // Sub.prototype.constructor = Sub;
        // const test = new Sub();
        // console.log(test);

    </script>
</body>

</html>