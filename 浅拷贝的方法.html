<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

    <script>
        //浅拷贝的实现方式
        //浅拷贝拷贝的是值，新旧对象在同一块内存中，修改新数据老数据也会改变
        // 1.  Object.assign()方法
        //assign()方法是把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是他的拷贝方式不是固定的.
        //该方法第一个参数是新对象，第二个参数是旧对象，旧对象中的属性值如果也是对象，那么新对象只是拷贝了内存地址
        // var obj = { a: 1, b: 2 }
        // var obj1 = Object.assign({},obj); 
        // obj1.a = 3; 
        // console.log(obj1.a) // 3


        // 使用es6的扩展运算符实现浅拷贝
        // const obj = {
        //     name: '张三',
        //     info: {
        //         age: 18
        //     }
        // };
        // const obj1 = {
        //     ...obj
        // };

        // Object.assign(obj1, obj);
        // obj.info.age = 20;
        // console.log(obj1); // 20
        // console.log(obj); // 20

        // 扩展运算符代码和使用Object.assign功能相同，其注意事项也相同，两者在使用上基本是可以相互转换


        // 数组的 concat 方法其实也是浅拷贝，使用场景比较少，
        // 使用concat连接一个含有引用类型的数组时，需要注意修改原数组中的元素的属性，因为它会影响拷贝之后连接的数组
        // const arr = [1, 2, { name: 'hhh' }];
        // const newArr = arr.concat();
        // newArr[2].name = 'hello';
        // console.log(arr);  // [1, 2, { name: 'hello' }];
        // console.log(newArr);  // [1, 2, { name: 'hello' }];

        // 会发现arr和newArr索引2的数据都由{name: 'hhh'}变成了{name: 'hello'}


        // 数组的 slice 方法其实也是浅拷贝，使用场景比较少，同cancat一样
        // const arr = [1, 2, { name: '你好' }];
        // const newArr = arr.slice();
        // newArr[2].name = '大家好';
        // console.log(arr);  // [1, 2, { name: '大家好' }];
        // console.log(newArr); // [1, 2, { name: '大家好' }];
    </script>

    <script>

        // 1. Object.assign()方法
        // var obj = { a: 1, b: 2 }
        // var obj1 = Object.assign({},obj); 
        // obj1.a = 3; 
        // console.log(obj1.a) // 3


        // 2.es6的扩展运算符实现浅拷贝
        // const obj = {
        //     name: '张三',
        //     info: {
        //         age: 18
        //     }
        // };
        // const obj1 = {
        //     ...obj
        // };
        // Object.assign(obj1, obj);
        // obj.info.age = 20;
        // console.log(obj1); // 20
        // console.log(obj); // 20

        

        // 数组的 concat 方法其实也是浅拷贝，使用场景比较少，
        // const arr = [1, 2, { name: 'hhh' }];
        // const newArr = arr.concat();
        // newArr[2].name = 'hello';
        // console.log(arr);  // [1, 2, { name: 'hello' }];
        // console.log(newArr);  // [1, 2, { name: 'hello' }];



        // 数组的 slice 方法其实也是浅拷贝，使用场景比较少，同cancat一样
        // const arr = [1, 2, { name: '你好' }];
        // const newArr = arr.slice();
        // newArr[2].name = '大家好';
        // console.log(arr);  // [1, 2, { name: '大家好' }];
        // console.log(newArr); // [1, 2, { name: '大家好' }];

    </script>

    <script>

        // 1. Object.assign()
        // var obj = { a: 1, b: 2 }
        // var obj1 = Object.assign({},obj); 
        // obj1.a = 3; 
        // console.log(obj1.a) // 3


        // 2.es6的扩展运算符
        // const obj = {
        //     name: '张三',
        //     info: {
        //         age: 18
        //     }
        // };
        // const obj1 = {
        //     ...obj
        // };
        // Object.assign(obj1, obj);
        // obj.info.age = 20;
        // console.log(obj1); // 20
        // console.log(obj); // 20

        

        // 数组的 concat 方法其实也是浅拷贝，使用场景比较少，
        // const arr = [1, 2, { name: 'hhh' }];
        // const newArr = arr.concat();
        // newArr[2].name = 'hello';
        // console.log(arr);  // [1, 2, { name: 'hello' }];
        // console.log(newArr);  // [1, 2, { name: 'hello' }];



        // 数组的 slice 方法其实也是浅拷贝，使用场景比较少，同cancat一样
        // const arr = [1, 2, { name: '你好' }];
        // const newArr = arr.slice();
        // newArr[2].name = '大家好';
        // console.log(arr);  // [1, 2, { name: '大家好' }];
        // console.log(newArr); // [1, 2, { name: '大家好' }];

    </script>
</body>

</html>